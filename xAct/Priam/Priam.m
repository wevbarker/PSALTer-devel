(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Code::Initialization:: *)
(*xAct`Priam`$Version={"1.0.0-beta",{2022,2,1}};*)
xAct`Priam`$Version={"1.0.0-developer",DateList@FileDate@$InputFileName~Drop~(-3)};


(* ::Code::Initialization:: *)
If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="xAct`Priam`"];


Off@(Solve::fulldim);


BeginPackage["xAct`Priam`",{"xAct`xTensor`","xAct`xPerm`","xAct`xCore`","xAct`xTras`","xAct`HiGGS`","xAct`FieldsX`"}];


(* ::Code::Initialization:: *)
Print[xAct`xCore`Private`bars];
Print["Package xAct`Priam`  version ",$Version[[1]],", ",$Version[[2]]];
Print["CopyRight \[Copyright] 2022, Will E. V. Barker, under the General Public License."];
Print[xAct`xCore`Private`bars];
Print["This free version of Priam is an open source dependent of HiGGS and the xAct bundle."];
(*Print[xAct`xCore`Private`bars];*)


(* ::Code::Initialization:: *)
(*Because the developer version of HiGGS is not installed, and sits locally, we need this*)
(*was Needs called on the HiGGS package from a notebook?*)
If[NotebookDirectory[]==$Failed,$WorkingDirectory=Directory[];,$WorkingDirectory=NotebookDirectory[];,$WorkingDirectory=NotebookDirectory[];];
(*Print["The working directory is "<>$WorkingDirectory];*)
$Path~AppendTo~$WorkingDirectory;
$PriamInstallDirectory=Select[FileNameJoin[{#,"xAct/Priam"}]&/@$Path,DirectoryQ][[1]];
(*Print["At least one Priam installation directory was found at "<>$PriamInstallDirectory<>"."];
Print[xAct`xCore`Private`bars];*)


(* ::Code::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="xAct`Priam`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]];


(* ::Code::Initialization:: *)
BuildPriam::usage="BuildPriam[] introduces a few new definitions.";
FourierLagrangian::usage="FourierLagrangian[Expr,Tensor1,Tensor2,...] transfers a scalar expression Expr which is quadratic in the given perturbed fields whose xTensor heads are Tensor1 and Tensor2 into its Fourier form. 
Both Expr and at least one field must be provided. Do not include indices in the fields, just list the xTensor heads (i.e. the tensor names).";
SaturateMe::usage="SaturateMe[Expr] produces the saturated propagator from the Lagrangian Expr, which must be a scalar of the form output by FourierLagrangian[].";


BuildLightcone::usage="BuildLightcone is a boolean option for BuildPriam, which determines whether the lightcone coordinates are constructed using xCoba.";


(* ::Code::Initialization:: *)
$PriamBuilt::usage="Did we already go over to the curved and torsionful geometry?";


(* ::Code::Initialization:: *)
Begin["xAct`Priam`Private`"];


$PriamBuilt=False;
BuildPriam::unbuilt="The HiGGS environment has not been built: you can build it by running BuildHiGGS[].";
Options@BuildPriam={BuildLightcone->True};
BuildPriam::built="The Priam environment has already been built.";
BuildPriam[OptionsPattern[]]:=Catch@Module[{PriorMemory,UsedMemory},
(*A message*)
xAct`xTensor`Private`MakeDefInfo[BuildPriam,$KernelID,{"Priam environment for kernel",""}];
(*Check for pre-existing build*)
If[xAct`HiGGS`Private`$HiGGSBuilt,Null,Throw@Message[BuildPriam::unbuilt],Throw@Message[BuildPriam::unbuilt]];
If[$PriamBuilt,Throw@Message[BuildPriam::built]];
(*List of all print cells in front end before this notebook starts to run*)
$PrintCellsBeforeStartBuildPriam=Flatten@Cells[SelectedNotebook[],CellStyle->{"Print"}];
Print[" ** BuildPriam: Building session from ",FileNameJoin@{$PriamInstallDirectory,"Priam_sources.nb"}];
Get[FileNameJoin@{$PriamInstallDirectory,"Priam_sources.m"}];
If[OptionValue@BuildLightcone,
Get[FileNameJoin@{$PriamInstallDirectory,"Priam_lightcone.m"}];
];
(*Purge all cells created during build process*)
Pause[2];
NotebookDelete@(Flatten@Cells[SelectedNotebook[],CellStyle->{"Print"}]~Complement~$PrintCellsBeforeStartBuildPriam);
Print[" ** BuildPriam: If build was successful, the Priam environment is now ready to use."];
$PriamBuilt=True;
];


FourierLagrangian[Expr_,Tensors__]:=Catch@Module[{CrossingRules,ToMomentumExpr,Tensors1,Tensors2,printer},
printer={};
printer=printer~Append~PrintTemporary@" ** FourierLagrangian...";
Tensors1=(#@@(ToExpression/@Alphabet[][[1;;(Length@SlotsOfTensor@#)]]))&/@(List@Tensors);
Tensors2=(#@@(ToExpression/@Alphabet[][[-(Length@SlotsOfTensor@#);;-1]]))&/@(List@Tensors);
CrossingRules={};(*start off without any rules*)
(*first the double derivatives*)
Table[(CrossingRules=CrossingRules~Join~
MakeRule[{Evaluate[Global`CD[-Global`q]@Tensor1 Global`CD[-Global`p]@Tensor2],Evaluate[Dagger@Tensor1 Global`P[-Global`p]Global`P[-Global`q]Tensor2]},MetricOn->All,ContractMetrics->True]),
{Tensor1,Tensors1},{Tensor2,Tensors2}];
(*then single derivatives*)
Table[(CrossingRules=CrossingRules~Join~
MakeRule[{Evaluate[Tensor1 Global`CD[-Global`p]@Tensor2],Evaluate[-I Dagger@Tensor1 Global`P[-Global`p]Tensor2]},MetricOn->All,ContractMetrics->True]),
{Tensor1,Tensors1},{Tensor2,Tensors2}];
(*and finally algebraic products*)
Table[(CrossingRules=CrossingRules~Join~
MakeRule[{Evaluate[Tensor1 Tensor2],Evaluate[Dagger@Tensor1 Tensor2]},MetricOn->All,ContractMetrics->True]),
{Tensor1,Tensors1},{Tensor2,Tensors2}];
ToMomentumExpr=Expr/.CrossingRules;(*now impose these rules to obtain Fourier space version*)
ToMomentumExpr=ToMomentumExpr//ToNewCanonical;
printer=printer~Append~PrintTemporary@ToMomentumExpr;
(*now move over to SO(3) decomposition*)
ToMomentumExpr=ToMomentumExpr/.Global`ToV;
ToMomentumExpr=ToMomentumExpr//ToNewCanonical;
ToMomentumExpr=ToMomentumExpr/.Global`GaugeDecompose//ToNewCanonical;
ToMomentumExpr=ToMomentumExpr/.Global`GaugePToGaugePO3/.Global`GaugePerpToGaugePO3//ToNewCanonical;
ToMomentumExpr=ToMomentumExpr//CollectTensors;
ToMomentumExpr=ToMomentumExpr/.Global`Patch2m;
ToMomentumExpr=ToMomentumExpr/.Global`ManualAll;
ToMomentumExpr=ToMomentumExpr/.Global`ManualAll;
ToMomentumExpr=ToMomentumExpr//ToNewCanonical;
ToMomentumExpr=ToMomentumExpr//CollectTensors;

Print@" ** FourierLagrangian: Lagrangian in Fourier space, decomposed among the SO(3) irreducible representations of the fields:";
Print["\!\(\*SuperscriptBox[OverscriptBox[\(\[Zeta]\), \(^\)], \(\[Dagger]\)]\)(\[ScriptK])\[CenterDot]\!\(\*OverscriptBox[\(\[ScriptCapitalO]\), \(^\)]\)(\[ScriptK])\[CenterDot]\!\(\*OverscriptBox[\(\[Zeta]\), \(^\)]\)(\[ScriptK]) = ",ToMomentumExpr];

NotebookDelete@printer;
ToMomentumExpr];


SaturateMe[Expr_]:=Catch@Module[{SymbolicLagrangian,Symbols,MatrixLagrangian,ImaginaryParts,RealParts,NullSpaces,SourceConstraints,MatrixPropagator,SaturatedPropagator,printer},
printer={};
printer=printer~Append~PrintTemporary@" ** SaturateMe...";

(*coefficient matrices*)
SymbolicLagrangian=Expr/.Global`cRules;(*remember the 2m mode turns out to vanish once you consider the cyclic identitiy on the indices!*)
Symbols=(#~Join~((Evaluate@Dagger[#])&/@#))&/@{Global`c0p,Global`c0m,Global`c1p,Global`c1m,Global`c2p,Global`c2m};(*lists of all the symbolic projected tensors*)
(*now transfer the Lagrangian to coefficient matrix form, accommodating for zero and dimension-one matrices*)
MatrixLagrangian=If[SparseArrayQ@Last@CoefficientArrays[SymbolicLagrangian,#,"Symmetric"->False],
Last@CoefficientArrays[SymbolicLagrangian,#,"Symmetric"->False],
SparseArray@ConstantArray[0,{Length@#,Length@#}]]&/@Symbols;
(*pick out the blocks of the coefficient arrays that are nonzero*)
MatrixLagrangian=#[[1;;(1/2)Length@#,(1/2)Length@#+1;;Length@#]]&/@MatrixLagrangian;
Print@" ** SaturateMe: Lagrangian as coefficient matrices for the HiGGS SO(3) decomposition of the gauge fields:";
Print@(MatrixForm/@MatrixLagrangian);

(*Hermitian versions of matrices*)
ImaginaryParts=Map[If[(MemberQ[Flatten@(Arg@#&/@FactorList[#]),Pi/2]||MemberQ[Flatten@(Arg@#&/@FactorList[#]),-Pi/2]),#,0]&,MatrixLagrangian,{3}];
RealParts=MatrixLagrangian-ImaginaryParts;
MatrixLagrangian=Simplify/@((1/2)(RealParts+Transpose/@RealParts)+(1/2)(ImaginaryParts-Transpose/@ImaginaryParts));
Print@" ** SaturateMe: Hermitian equivalent of these coefficient matrices:";
Print@(MatrixForm/@MatrixLagrangian);

(*rescaled versions of matrices*)
MatrixLagrangian=MapThread[MapThread[#1 #2&,{#1,#2}]&,{MatrixLagrangian,Global`rescmat}]/.Global`rescsols;
Print@" ** SaturateMe: SPO-rescaled equivalent of these coefficient matrices:";
Print@(MatrixForm/@MatrixLagrangian);

(*null spaces*)
NullSpaces=NullSpace@Transpose[#]&/@MatrixLagrangian;
Print@" ** SaturateMe: Null spaces of these coefficient matrices:";
Print@NullSpaces;

(*source constraints*)
SourceConstraints=Quiet@DeleteCases[Flatten@MapThread[#1 . #2&,{If[#=={},{0},#,#]&/@NullSpaces,MapThread[MapThread[(#2/#1)&,{#1,#2}]&,{{Global`r0p,Global`r0m,Global`r1p,Global`r1m,Global`r2p,Global`r2m},Global`Ups}]}],0,Infinity]/.Global`rescsols;
SourceConstraints=Numerator@Together[#/Sqrt[2^5*3^5*5^5*7^5]]&/@SourceConstraints;
Print@" ** SaturateMe: Corresponding source constraints:";
Print[#," = 0"]&/@SourceConstraints;

(*matrix form of the propagator*)
MatrixPropagator=FullSimplify@ComplexExpand@DrazinInverse[#]&/@MatrixLagrangian;
Print@" ** SaturateMe: Matrix propagator as the Drazin (Moore-Penrose) inverse of the Hermition, SPO-rescaled matrix Lagrangian:";
Print@(MatrixForm/@MatrixPropagator);

(*saturated form of the propagator*)
MatrixPropagator=MapThread[MapThread[#1 #2&,{#1,#2}]&,{MatrixPropagator,Global`invrescmat}]/.Global`rescsols;(*descale the propagator ready for multiplication by sources*)
SaturatedPropagator=MapThread[#1 . #2 . #3&,{Dagger/@Global`Ups,MatrixPropagator,Global`Downs}];
SaturatedPropagator=ToNewCanonical/@SaturatedPropagator;
SaturatedPropagator=CollectTensors/@SaturatedPropagator;
Print@" ** SaturateMe: Saturated propagator:";
Print["\!\(\*SuperscriptBox[OverscriptBox[\(\[ScriptJ]\), \(^\)], \(\[Dagger]\)]\)(\[ScriptK])\[CenterDot]\!\(\*SuperscriptBox[OverscriptBox[\(\[ScriptCapitalO]\), \(^\)], \(-1\)]\)(\[ScriptK])\[CenterDot]\!\(\*OverscriptBox[\(\[ScriptJ]\), \(^\)]\)(\[ScriptK]) = ",Evaluate@ToNewCanonical@Total@SaturatedPropagator];

NotebookDelete@printer;
{SourceConstraints,SaturatedPropagator}];


MakeConstraintComponentList[PropagatorConstraints_List,ManualConstraints_List:{}]:=Catch@Module[{AllConstraints,ConstraintComponents},
(*First join up the automatically and manually derived constraints lists*)
AllConstraints=PropagatorConstraints~Join~ManualConstraints;
(*Obtain nested lists of all the Cartesian components of the vanishing constraint functions*)
ConstraintComponents=If[Length@FindFreeIndices@#!=0,xAct`xCoba`ComponentArray[xAct`xCoba`FreeToBasis[Global`cartesian]@#],#]&/@AllConstraints;
(*Flatten them*)
ConstraintComponents=Flatten@ConstraintComponents;
(*Use the symmetries of the SO(3) irreps to "canonicalise" these component expressions via folded rules*)
(ConstraintComponents=ConstraintComponents/.xAct`xCoba`TensorValues@#)&/@{Global`TauP1p,Global`SigmaP1p,Global`SigmaPerp1p,Global`TauP1m,Global`SigmaP1m,Global`TauPerp1m,Global`SigmaPerp1m,Global`TauP2p,Global`SigmaP2p,Global`SigmaP2m};
(*Remove symmetry-vanishing and duplicate entries that the "canonicalisation" reveals*)
ConstraintComponents=ConstraintComponents~DeleteCases~0;
ConstraintComponents=ConstraintComponents//DeleteDuplicates;
ConstraintComponents];


(* ::Code::Initialization:: *)
End[];
EndPackage[];
